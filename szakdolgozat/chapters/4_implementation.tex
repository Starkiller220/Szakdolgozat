\Chapter{Megvalósítás}

Itt történik az elkészült szoftver megvalósításának bemutatása, az előző fejezetben leírt terv szempontjai alapján.

\Section{DosBox}

\subsection{Buildelés}
Első lépésként a forráskódot kell beszerezni, ez a beszerzés időpontjában elérhető legfrissebb verzióban történt meg, a további frissítése új verziókra csak abban az esetben indokolt ha kritikus hibát találok a fejlesztés során, egyébként csak komplikációk adódnának miatta.
% ref: https://sourceforge.net/p/dosbox/code-0/4392/tree/dosbox/

A következő lépés a beszerzett forráskód buildelése. Mivel jelenleg a Windowst használom gyakrabban, így a DosBox buildelése, és a mesterséges intelligencia is Windows alatt fog készülni. Nem lehetetlen hogy Linux alatt is elindulni mind a Dosbox, mind az MI, de a szakdolgazat nem foglalkozik erre az operációs rendszerre történő optimalizálásra.
% ref: https://www.dosbox.com/wiki/Building_DOSBox_with_Visual_Studio

Ha megpróbálnánk így lefordítani, azonnal hibába ütköznénk, ugyanis szükségesek hozzá különböző könyvtárak.

\begin{itemize}

    \item SDL (Simple DirectMedia Layer)
    
    Az egyetlen kötelező könyvtár és talán legfontosabb. Az SDL egy több platformos fejlesztői könyvtár, amelyet arra találtak ki, hogy alacsony szintő hozzáférést biztosítson többek között az egérhez, billentyűzethez, különböző játékvezérlőkhöz, magához a hanghoz OpenGL és Direct3D segítségével. Rengeteg híres videojáték használja ezt a technológiát. Sajnos a DosBox elég válogatós, így a leírás alapján nem a legfirsebb verziót kéri, hanem egy jóval régebbi kiadást.
    \item zlib / libpng (opcionális)
    
    Egy opcionális könyvtár képek és videók mentésére. A tervben vázoltak alapján arra következtetünk, hogy ez még a hasznunkra vállhat, így mind a két könyvtárat is le kell töltenünk, mivel a \textit{libpng} követelménye a \textit{zlib}. 
    \item SDL\_net (opcionális)
    
    Lehetővé teszi a hálózat használatát. A többjátékos mód eléréséhez elengedhetetlen, ugyanakkor nincs tervben ennek a használata. Amennyiben ez módosul, ezt is hozzáadjuk a könyvtárakhoz.
    \item SDL\_sound (opcionális)
    
    Lejátszhatóak lesznek a tömörített hanggal rendelkező CD-k.
    \item PDCurses (opcionális)
    
    Elérhetővé teszi a DOS Debuggert.

\end{itemize}

Miután eldöntöttük mely könyvtárak szükségesek nekünk a fordításhoz, a fordítási útmutató alapján beállítjuk a linkereket megfelelően, és a szükséges DLL fájlokat is. 

Utolsó dolgunk átírni a \textit{config.h} nevű fájlban az alábbi konfigurációkat: 

\begin{cpp}

    ...
    #define C_DEBUG 0 // PDCurses

    #define C_SSHOT 1 // libpng

    #define C_SRECORD 1 // zlib

    #define C_MODEM 0 // SDL_net 

    #define C_IPX 0 // SDL_net 
    ...
\end{cpp}

\subsection{DosBox átalakítása - bemenetek}

Ahhoz hogy a tervben leírtakat meg tudjuk valósítani, meg kell találnuk a számunkra fontos kódrészeket. Ezek sorrendtől függetlenül a következők:

\begin{itemize}
    \item Egér 
    \item Billentyűzet
    \item Képernyőkép
\end{itemize}

A fájlok közül rákereshetünk hogy tartalmazza-e valamelyik a keyboard vagy mouse kulcsszavatak. Ezekre rákeresve találunk 2 fájlt ami számunkra érdekes lehet. Az egyik a \textit{keyboard.h} a másik a \textit{mouse.h}.

Így néz ki például a \textit{keyboard.h} header fájl:

\begin{cpp}
    #ifndef DOSBOX_KEYBOARD_H
    #define DOSBOX_KEYBOARD_H
    
    enum KBD_KEYS {
        KBD_NONE,
        KBD_1,	KBD_2,	KBD_3,	KBD_4,	KBD_5,	KBD_6,	KBD_7,	
        KBD_8,	KBD_9,	KBD_0,		
        KBD_q,	KBD_w,	KBD_e,	KBD_r,	KBD_t,	KBD_y,	KBD_u,	
        KBD_i,	KBD_o,	KBD_p,	
        KBD_a,	KBD_s,	KBD_d,	KBD_f,	KBD_g,	KBD_h,	KBD_j,	
        KBD_k,	KBD_l,	KBD_z,
        KBD_x,	KBD_c,	KBD_v,	KBD_b,	KBD_n,	KBD_m,	
        KBD_f1,	KBD_f2,	KBD_f3,	KBD_f4,	KBD_f5,	KBD_f6,	KBD_f7,	
        KBD_f8,	KBD_f9,	KBD_f10,KBD_f11,KBD_f12,

        ...
        
    };
    
    void KEYBOARD_ClrBuffer(void);
    void KEYBOARD_AddKey(KBD_KEYS keytype,bool pressed);
    
    #endif
\end{cpp}

Látható hogy a különböző billentyűk egy enumban vannak tárolva, általános alakját tekintve \textit{KBD\_KEY}.
Továbbá a fájl végén található egy függvény fejléce:

\begin{cpp}
    void KEYBOARD_AddKey(KBD_KEYS keytype,bool pressed);
\end{cpp}

Itt látható hogy ez a függvény paraméterbe kér egy billentyűt, a fentebb látott enumból, majd egy igaz/hamis értéket, hogy le van-e nyomva avagy sem. Ebből tisztán látszik, hogy amennyiben meghívjuk ezt a függvényt egy gombra igaz paraméterre, majd közvetenül utána hamissal, gomblenyomást tudunk szimulálni kódon belül. 

Ezzel a billentyűzethez hozzá tudunk férni igen egyszerűen, következhet is az egér, amelyet a \textit{mouse.h} header fájlban találunk.

\begin{cpp}

    #ifndef DOSBOX_MOUSE_H
    #define DOSBOX_MOUSE_H
    
    
    void Mouse_ShowCursor(void);
    void Mouse_HideCursor(void);
    
    bool Mouse_SetPS2State(bool use);
    
    void Mouse_ChangePS2Callback(Bit16u pseg, Bit16u pofs);
    
    void Mouse_CursorMoved(float xrel,float yrel,
                           float x,float y,bool emulate);

    void Mouse_CursorSet(float x,float y);
    void Mouse_ButtonPressed(Bit8u button);
    void Mouse_ButtonReleased(Bit8u button);
    
    void Mouse_AutoLock(bool enable);
    void Mouse_BeforeNewVideoMode(bool setmode);
    void Mouse_AfterNewVideoMode(bool setmode);
    
    #endif

\end{cpp}

Itt már nehezebb dolgunk van mint a billentyűzetnél. Vannak ugyan egyszerűbb fügvények is, mint például a \verb|Mouse_ShowCursor(void)| és a \verb|Mouse_ShowCursor(void)| amelyekkel el lehet tűntetni, majd ismét meglejeníteni a kurzort,
És a\\ \verb|Mouse_CursorSet(float x,float y)| működése is evidens, a képernyő 2 koordinátáját kell megadni és a kurzort oda rakja.

Ennél bonyolultabb függvény a \verb|Mouse_ButtonPressed(Bit8u button)| és a hozzá tartozó \verb|Mouse_ButtonReleased(Bit8u button)|. A használatát tekintve első ránézésre hasonlónak tűnik mint a billentyűzetnél lévő függvény. Ugyanakkor mivel a \textit{Bit8u} nem egy alapértelmezett típus, érdemes betekinteni a függvény definíciójába, hogy pontosan megértsük mit is vár el paraméternek.

Vegyük például a gomb lenyomásához tartozó függvényt:
\begin{cpp}

    void Mouse_ButtonPressed(Bit8u button) {
            switch (button) {
        #if (MOUSE_BUTTONS >= 1)
            case 0:
                if (mouse.buttons&1) return;
                mouse.buttons|=1;
                Mouse_AddEvent(MOUSE_LEFT_PRESSED);
                break;
        #endif
        #if (MOUSE_BUTTONS >= 2)
            case 1:
                if (mouse.buttons&2) return;
                mouse.buttons|=2;
                Mouse_AddEvent(MOUSE_RIGHT_PRESSED);
                break;
        #endif
        #if (MOUSE_BUTTONS >= 3)
            case 2:
                if (mouse.buttons&4) return;
                mouse.buttons|=4;
                Mouse_AddEvent(MOUSE_MIDDLE_PRESSED);
                break;
        #endif
            default:
                return;
            }
        mouse.times_pressed[button]++;
        mouse.last_pressed_x[button]=POS_X;
        mouse.last_pressed_y[button]=POS_Y;
    }

\end{cpp}

Látható hogy annak fügvényében hogy mennyi gomb található az egéren (alapértelmezetten 3), az alapján engedélyez különböző eseteket a program. Alapértelmezett esetben az alábbiakra tudunk következtetni:

\begin{itemize}
    \item Ha a \textit{button} paraméter értéke 0, az a bal egérgombnak felel meg
    \item Amennyiben az értéke 1, akkor az a jobb egérgomb
    \item Amennyiben az érték 2, akkor az a görgő lenyomása
\end{itemize}

Ezt kombinálva a gomb eleresztésével láthatóvá válik, hogy ugyan úgy képesek vagyunk kattintani 2 függvény meghívásával, mint ahogyan ezt a billentyűzetnél tettük.

\subsection{Dosbox átalakítása - képernyőkép}

További fontos, ugyanakkor nehezebb probléma a képernyő képének lementése. Első lépésként meg kell találni a az ehhez szükséges függvényt vagy függvényeket. 
A \textit{screenshot} szóra rákeresve a fájlok között a \textit{hardware.cpp}-ben találunk egy\\ \verb|CAPTURE_ScreenShotEvent| nevű függvényt, ugyanakkor ez nem paraméterezhető megfeleően, csak egy igaz/hamis értéket lehet megadni benne. 
Tovább böngészve ugyan ebben a fájlban megtalálhatjuk a \verb|CAPTURE_AddImage| függvényt, mely számos paraméterrel rendelkezik, a függvény definíciójában pedig megtalálható a menteni kívánt fájl kiterjesztése is.

Ezek után olyan részt kell találni a kódban, ahol periodikusan lehet futtatni az általunk megírt logika alapján a kép lementését anélkül, hogy lassítanánk a szoftver futását. Erre hosszadalmas keresés után a \textit{render.cpp} \verb|RENDER_EndUpdate| függvénye tűnik alkalmasnak, mivel ez a függvény minden frame végén lefut. 
A függvény végét az alábbi kóddal bővítettem ki:
\begin{cpp}

    if(1)
    {
        ...

        if (fpsCounter >= render.src.fps)
        {
            CAPTURE_AddImage(render.src.width==0?640:render.src.width, 
                             render.src.height==0?400:render.src.height, 
                             render.src.bpp, pitch,
                             flags, fps, (Bit8u*)&scalerSourceCache, 
                             (Bit8u*)&render.pal.rgb);
            CaptureState = 0;
            fpsCounter = 0;
        }
    
        else
        {
            fpsCounter++;
        } 
    }

    

\end{cpp}
Ennek a lényege, hogy létrehozunk egy belső FPS számlálót, és minden frameben összehasonlítjuk az elvárt FPS-el, amennyiben ezt elértük vagy túlhaladtunk rajta, lementjük a képernyő jelenlegi tartalmát.
Ezzel technikailag másodpercenként lehet képernyőképet csinálni. Ezzel a módszerrel ez a lehető legrövidebb intervallum.
\subsection{Dosbox átalakítása - ZeroMQ}

Miután elkészült a képernyőkép bizonyos időközönkénti mentése, egy újabb nehezebb feladat következik. Implementálnunk kell a tervben leírt processzek közötti kommunikációt. 
Erre a már szintén említett \textit{ZeroMQ} lesz a segítségünkre, amit először tesztelnünk kell C++ban és Pythonban egyaránt.

Mielőtt konkrétan beágyaznánk bármiféle kódot a DosBoxba, nézzük meg hogyan is működik egy egszerű \textit{request-reply} alapján.

\begin{python}

    import zmq
    import time

    context = zmq.Context()

    #  create socket
    print("Connecting to server...")
    socket = context.socket(zmq.REQ)
    socket.connect("tcp://localhost:5555")

    #  Do 10 request and wait for reply
    for request in range(10):
        print("Sending request %s ..." % request)
        msg = input("message: ")
        socket.send(bytes(msg))

        
        #  Get the reply.
        message = socket.recv()
        print("Received reply %s [ %s ]" % (request, message))
\end{python}

Itt az látható, hogy létrehozunk egy kontextust, majd ebből egy socketet melynek a \textit{request} típust adjuk. 
Utána megadjuk a kapcsolat típusát, címét és a portot. Ebben a mintában 10 üzenetet tudunk küldeni, amit byte sorozatként küldi el, és minden üzenet után megvárjuk a választ. Ez lényegében a kliensünk, a következő, már C++ban írt kód pedig a szerver lesz, ami fogadja az üzeneteket és választ ad rájuk.

\begin{cpp}
    #include <zmq.hpp>
    #include <string>
    #include <iostream>
    #include <windows.h>
    int main()
    {
        zmq::context_t context(1);
        zmq::socket_t socket(context, ZMQ_REP);
        socket.bind("tcp://*:5555");
    
        while (true) {
            zmq::message_t request;
    
            //  Wait for request
            socket.recv(&request);
            std::cout << "Received " << request.to_string() << std::endl;
    
            //  Do some 'work'
            Sleep(1);
    
            //  Send reply 
            zmq::message_t reply(5);
            memcpy(reply.data(), "Hello", 5);
            socket.send(reply);
        }
        return 0;
    }
\end{cpp}

Felépítést tekintve nagyon hasonló a az előző kódhoz, de mivel szerverként funkcionál, így üzenetre vár, majd aztán küld egy válasz üzenetet. 

Értelem szerűen ezt a kódrészt kell a DosBoxba integrálni míg az előzőt a mesterséges intelligenciába kell beágyazni. Először megkeressük azt a kódrészt ahová ezt, vagy ennek egy módosított változatát be tudjuk integrálni. Jó gondolat a jól megszokott \textit{render.cpp}-be történő bővítés, ugyanis folyamatosan figyelni kell az üzenetet és reagálni rá. Viszont ezt kipróbálva abba a problémába ütközünk, hogy a program addig "lefagy" amíg nem kap üzenetet. Ez ividens, ugyanis a \verb|socket.recv(&request)| sor lényege, hogy addig vár, amíg nem kap üzenetet. Ezt egy végtelen ciklusba rakva láthatóvá válik mi is a gond.

Ennek kiküszöbölése érdekében egy külön függvényben kell definiálni a szerver kódját, majd egy új szálat indítani, és ennek párhuzamosan kell futnia a program többi részével. Így nem fagy le a programunk, és a fentebb leírt periféria manipuláló függvényeket is meg tudjuk hívni.
\pagebreak
\begin{cpp}

    void ZeroMQLoop()
    {
    
        zmq::context_t context(1);
        zmq::socket_t socket(context, ZMQ_REP);
        socket.bind("tcp://*:5555");
    
        while (true) {
            zmq::message_t request;
    
            //  Wait for next request from client
            socket.recv(&request);
            LOG_MSG(request.to_string().c_str());
    
            std::vector<std::string> result;
            std::istringstream iss(request.to_string());
            for (std::string s; iss >> s; )
                result.push_back(s);
    
            if (result[0] == "Mouse")
            {
                LOG_MSG(result[1].c_str());
                LOG_MSG(result[2].c_str());
                //Mouse_CursorSet(0,0);
                Mouse_CursorSet(stof(result[1]), stof(result[2]));
                Mouse_ButtonPressed(0);
                Mouse_ButtonReleased(0);
            }
    
            else if (result[0] == "start")
            {
                KEYBOARD_AddKey(KBD_s, 1);
                KEYBOARD_AddKey(KBD_s, 0);
                Sleep(500);
                KEYBOARD_AddKey(KBD_u, 1);
                KEYBOARD_AddKey(KBD_u, 0);
                Sleep(500);
                KEYBOARD_AddKey(KBD_m, 1);
                KEYBOARD_AddKey(KBD_m, 0);
                Sleep(500);
                // Click to Forest
                KEYBOARD_AddKey(KBD_o, 1);
                KEYBOARD_AddKey(KBD_o, 0);
            }
    
            //  Send reply
            zmq::message_t reply(5);
            memcpy(reply.data(), "Done", 4);
            
            socket.send(reply);
        }
    }

    
\end{cpp}